<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Project 2 — Fun with Filters and Frequencies</title>
  <style>
    :root { --maxw: 980px; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0; line-height: 1.6; color: #222; background: #fafafa;
    }
    header, main, footer { max-width: var(--maxw); margin: 0 auto; padding: 20px; }
    header h1 { margin: 0 0 6px; }
    header a { color: #0b5fff; text-decoration: none; }
    section {
      background: #fff; border: 1px solid #eee; border-radius: 14px;
      padding: 18px; margin: 18px 0 24px; box-shadow: 0 1px 3px rgba(0,0,0,.05);
    }
    h2 { margin: 0 0 12px; font-size: 1.25rem; }
    h3 { margin: 8px 0 8px; font-size: 1.1rem; }
    p { margin: 8px 0; }
    pre { background:#0f172a; color:#e5e7eb; padding:14px; border-radius:10px; overflow:auto; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .grid-2 { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:12px; }
    .grid-4 { display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:12px; }
    @media (max-width: 900px) { .grid-4 { grid-template-columns:repeat(2,minmax(0,1fr)); } }
    @media (max-width: 720px) { .grid-2 { grid-template-columns:1fr; } }
    figure { margin:0; border:1px solid #eee; border-radius:12px; overflow:hidden; background:#fff; }
    figure img, figure video { display:block; width:100%; height:auto; }
    figcaption { font-size:.9rem; padding:10px 12px; background:#f6f7fb; border-top:1px solid #eee; }
    .answer { background:#f4fbf6; border:1px solid #d8f1df; border-radius:10px; padding:10px 12px; margin-top:10px; }
    .note { font-size:.92rem; color:#555; background:#fff7e6; border:1px solid #ffe2a8; border-radius:10px; padding:10px 12px; margin-top:10px; }
    footer { font-size:.9rem; color:#666; }
    .back { display:inline-block; margin-top:6px; }
    ul.tight { margin:8px 0; padding-left: 18px; }
    .grid-3 { display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:12px; }
  </style>
  <!-- MathJax for nicely typeset matrices/equations -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <header>
    <h1>Project 2 — Fun with Filters and Frequencies</h1>
    <a class="back" href="../index.html">← Back to main portfolio</a>
  </header>

  <main>
    <!-- Part 1 -->
    <section id="part1">
      <h2>Part 1 — Fun with Filters</h2>

      <!-- Part 1.1 -->
      <section id="part1-1">
        <h3>Part 1.1 — Convolutions from Scratch</h3>
        <p>The core operators are implemented from scratch with zero-padding (SAME output). A 4-loop version is kept for clarity; a 2-loop version vectorizes the kernel multiply-add for speed.</p>

<pre><code># Zero-padding to keep SAME output size
import numpy as np

def zero_pad(img, ph, pw, value=0.0):
    H, W = img.shape
    out = np.full((H + 2*ph, W + 2*pw), value, dtype=img.dtype)
    out[ph:ph+H, pw:pw+W] = img
    return out

# Convolution with four loops (reference, slowest)
def conv2d_4loops(img, kernel):
    H, W = img.shape
    kh, kw = kernel.shape
    ph, pw = kh//2, kw//2
    kflip = kernel[::-1, ::-1]
    pad = zero_pad(img, ph, pw)
    out = np.empty_like(img, dtype=np.float64)
    for i in range(H):
        for j in range(W):
            acc = 0.0
            for u in range(kh):
                for v in range(kw):
                    acc += kflip[u, v] * pad[i+u, j+v]
            out[i, j] = acc
    return out

# Convolution with two loops (kernel window multiply-add vectorized)
def conv2d_2loops(img, kernel):
    H, W = img.shape
    kh, kw = kernel.shape
    ph, pw = kh//2, kw//2
    kflip = kernel[::-1, ::-1]
    pad = zero_pad(img, ph, pw)
    out = np.empty_like(img, dtype=np.float64)
    for i in range(H):
        for j in range(W):
            window = pad[i:i+kh, j:j+kw]
            out[i, j] = np.sum(window * kflip)
    return out
</code></pre>

        <h3>Quick comparison (qualitative/quantitative)</h3>
        <div class="answer">
          <ul class="tight">
            <li><strong>Correctness:</strong> 4-loops ≈ 2-loops ≈ SciPy <code>signal.convolve2d</code> (with same padding) up to tiny FP error.</li>
            <li><strong>Runtime (typical):</strong> SciPy C-optimized &gt;&gt; 2-loops (vectorized inner product) &gt;&gt; 4-loops (pure Python). The gap widens for larger kernels.</li>
            <li><strong>When to use:</strong> 4-loops for pedagogy; 2-loops for simple NumPy-only speedup; SciPy for production or large images.</li>
          </ul>
        </div>
        <div class="note">Padding: Using <em>zero padding</em> so the output height/width match the input (SAME). Different boundary modes (mirror/wrap) change border behavior slightly.</div>

        <h3>Kernels used</h3>
<pre><code># 9×9 box filter
box9 = np.ones((9, 9), dtype=np.float64) / 81.0

# Finite-difference operators
Dx = np.array([[ 1.0, 0.0, -1.0 ]], dtype=np.float64)   # horizontal derivative (vertical edges)
Dy = Dx.T                                               # vertical derivative (horizontal edges)
</code></pre>

        <h3>Typeset view of filters</h3>
        <p>The same filters rendered as formulas for clarity:</p>
        <div class="answer">
          <p>Finite differences:</p>
          <p>\[ D_x = \begin{bmatrix} 1 & 0 & -1 \end{bmatrix},\qquad
             D_y = \begin{bmatrix} 1 \\ 0 \\ -1 \end{bmatrix} \]</p>
          <p>9×9 box (mean) filter:</p>
          <p>\[ B = \frac{1}{81}\,\underbrace{\begin{bmatrix}
                1 & 1 & \cdots & 1 \\
                1 & 1 & \cdots & 1 \\
                \vdots & \vdots & \ddots & \vdots \\
                1 & 1 & \cdots & 1
             \end{bmatrix}}_{9\times 9} \]</p>
        </div>

        <h3>Results (Christopher Nolan)</h3>
          <p>Five views: original (color), grayscale, box-filtered, and finite-difference responses along x/y.</p>
          <div class="grid-auto">
          <figure>
          <img src="Media/Christopher_Nolan.png" alt="Christopher Nolan original (color)" loading="lazy">
          <figcaption>Christopher Nolan Original (Color)</figcaption>
          </figure>
          <figure>
          <img src="Media/nolan_grayscale.png" alt="Christopher Nolan grayscale" loading="lazy">
          <figcaption>Christopher Nolan Grayscaled</figcaption>
          </figure>
          <figure>
          <img src="Media/nolan_processed_box.png" alt="Christopher Nolan convolved with 9x9 box filter" loading="lazy">
          <figcaption>Christopher Nolan Box Filter (9×9) Convolved</figcaption>
          </figure>
          <figure>
          <img src="Media/nolan_processed_Dx.png" alt="Christopher Nolan convolved with Dx" loading="lazy">
          <figcaption>Christopher Nolan Operator Dx Convolved</figcaption>
          </figure>
          <figure>
          <img src="Media/nolan_processed_Dy.png" alt="Christopher Nolan convolved with Dy" loading="lazy">
          <figcaption>Christopher Nolan Operator Dy Convolved</figcaption>
          </figure>
          </div>
      </section>
    </section>

    <section id="part1-2">
      <h3>Part 1.2 — Finite Difference Operator</h3>
        <p>Convolve the Cameraman image with <code>D_x</code> and <code>D_y</code> to obtain partial derivatives; compute the gradient magnitude; then binarize it with qualitative thresholds.</p>
        
        
        <h4>Partial derivatives (Cameraman)</h4>
        <div class="grid-2">
        <figure>
        <img src="Media/cameraman_convolved_Dx.png" alt="Cameraman convolved with Dx" loading="lazy">
        <figcaption>∂I/∂x via <code>D_x</code></figcaption>
        </figure>
        <figure>
        <img src="Media/cameraman_convolved_Dy.png" alt="Cameraman convolved with Dy" loading="lazy">
        <figcaption>∂I/∂y via <code>D_y</code></figcaption>
        </figure>
        </div>
        
        
        <h4>Gradient magnitude</h4>
        <figure>
        <img src="Media/cameraman_grad_mag.png" alt="Gradient magnitude |∇I| of Cameraman" loading="lazy">
        <figcaption>Gradient magnitude image: |∇I| = √(Gx² + Gy²).</figcaption>
        </figure>
        
        
            <h4>Edge images by binarizing |∇I|</h4>
            <p>Threshold rule: <code>Mag &gt; ratio × Mag.max()</code>, with <code>ratio ∈ {0.1, 0.2, 0.3, 0.4}</code>.</p>
            <div class="grid-2">
              <figure>
                <img src="Media/cameraman_edges_01.png" alt="Edges with ratio=0.1" loading="lazy">
                <figcaption>Edges (ratio = 0.10)</figcaption>
              </figure>
              <figure>
                <img src="Media/cameraman_edges_02.png" alt="Edges with ratio=0.2" loading="lazy">
                <figcaption>Edges (ratio = 0.20)</figcaption>
              </figure>
              <figure>
                <img src="Media/cameraman_edges_03.png" alt="Edges with ratio=0.3" loading="lazy">
                <figcaption>Edges (ratio = 0.30)</figcaption>
              </figure>
              <figure>
                <img src="Media/cameraman_edges_04.png" alt="Edges with ratio=0.4" loading="lazy">
                <figcaption>Edges (ratio = 0.40)</figcaption>
              </figure>
            </div>
            
            <p class="answer">
              <strong>Best threshold:</strong> Based on qualitative assessment, the best result is at <code>ratio = 0.20</code>,
              which suppresses most noise while preserving true edges.
            </p>
        </section>

        <!-- Part 1.3 -->
          <section id="part1-3">
          <h3>Part 1.3 — Derivative of Gaussian (DoG) Filter</h3>
          
          
          <!-- Subpart A: Gaussian-smoothed version -->
          <section id="part1-3a">
          <h4>Gaussian-smoothed version</h4>
          <p>First, blur the original image with a Gaussian filter <code>G</code>, then repeat the previous procedure: compute partial derivatives and binarize the gradient magnitude with qualitative thresholds.</p>
          
          
          <h5>Original vs. Gaussian-blurred</h5>
          <div class="grid-2">
          <figure>
          <img src="Media/cameraman.png" alt="Cameraman original" loading="lazy">
          <figcaption>Original (Cameraman)</figcaption>
          </figure>
          <figure>
          <img src="Media/A_smoothed.png" alt="Cameraman blurred with Gaussian" loading="lazy">
          <figcaption>Blurred with Gaussian <code>G</code></figcaption>
          </figure>
          </div>
          
          
          <h5>Derivatives on smoothed image</h5>
          <div class="grid-2">
          <figure>
          <img src="Media/A_gradx.png" alt="dx on smoothed" loading="lazy">
          <figcaption>∂I/∂x on smoothed</figcaption>
          </figure>
          <figure>
          <img src="Media/A_grady.png" alt="dy on smoothed" loading="lazy">
          <figcaption>∂I/∂y on smoothed</figcaption>
          </figure>
          </div>
          
          
          <h5>Edge images by binarizing |∇I| (on smoothed)</h5>
          <p>Threshold rule: <code>Mag &gt; ratio × Mag.max()</code> with <code>ratio ∈ {0.1, 0.2, 0.3, 0.4}</code>.</p>
          <div class="grid-2">
          <figure>
          <img src="Media/A_grad_mag.png" alt="Gradient magnitude image" loading="lazy">
          <figcaption>Gradient magnitude image</figcaption>
          </figure>
          <figure>
          <img src="Media/Smoothing_edges_r10.png" alt="edges r=0.1 on smoothed" loading="lazy">
          <figcaption>Edges (ratio = 0.10)</figcaption>
          </figure>
          <figure>
          <img src="Media/Smoothing_edges_r20.png" alt="edges r=0.2 on smoothed" loading="lazy">
          <figcaption>Edges (ratio = 0.20)</figcaption>
          </figure>
          <figure>
          <img src="Media/Smoothing_edges_r30.png" alt="edges r=0.3 on smoothed" loading="lazy">
          <figcaption>Edges (ratio = 0.30)</figcaption>
          </figure>
          </div>
          
          
          <div class="note">
          <strong>What differences do we see vs. Part&nbsp;1.2?</strong>
          Smoothing suppresses high-frequency noise, so derivatives are cleaner and edges more continuous; tiny textures are attenuated. Compared with Part&nbsp;1.2 (no smoothing), weak and noisy responses are reduced while main object contours remain. And this is especially true for our chosen threshold 0.20!
          </div>
          </section>

          <!-- Subpart B: Gaussian filters directly (DoG) -->
          <section id="part1-3b">
          <h4>Gaussian filters directly (DoG)</h4>
          <p>Instead of two convolutions (blur then differentiate), we can convolve the Gaussian with the finite-difference filters to obtain derivative-of-Gaussian (DoG) filters, then apply them once to the image.</p>
          
          
          <h5>Example Gaussian filter</h5>
          <div class="answer">
          <p>One common 3×3 Gaussian approximation is</p>
          <p>\[ G = \tfrac{1}{256}\begin{bmatrix}
                1 & 4 & 6 & 4 & 1 \\
                4 & 16 & 24 & 16 & 4 \\
                6 & 24 & 36 & 24 & 6 \\
                4 & 16 & 24 & 16 & 4 \\
                1 & 4 & 6 & 4 & 1
              \end{bmatrix} \]</p>
          <p>In our experiments we used a larger separable Gaussian (e.g., <code>ksize=25</code>, <code>σ=1.5</code>) generated via <code>cv2.getGaussianKernel</code>.</p>
          </div>
          
          
          <h5>DoG filters (visualized)</h5>
          <div class="grid-2">
          <figure>
          <img src="Media/DoGx_kernel.png" alt="Derivative of Gaussian (Dx * G)" loading="lazy">
          <figcaption>DoG filter in x (G * D<sub>x</sub>)</figcaption>
          </figure>
          <figure>
          <img src="Media/DoGy_kernel.png" alt="Derivative of Gaussian (Dy * G)" loading="lazy">
          <figcaption>DoG filter in y (G * D<sub>y</sub>)</figcaption>
          </figure>
          </div>
          
          
          <h5>Apply DoG to the image (single convolution)</h5>
          <div class="grid-2">
          <figure>
          <img src="Media/B_gradx.png" alt="dx via DoG" loading="lazy">
          <figcaption>∂I/∂x via DoG</figcaption>
          </figure>
          <figure>
          <img src="Media/B_grady.png" alt="dy via DoG" loading="lazy">
          <figcaption>∂I/∂y via DoG</figcaption>
          </figure>
          </div>
          
          
          <div class="answer">
          <strong>Same result, one pass.</strong>
          The images <em>dx/dy on smoothed</em> (Subpart&nbsp;A) and <em>dx/dy via DoG</em> (this section) are numerically the same up to tiny floating‑point error, because convolution is associative: \[ (I \ast G) \ast D \equiv I \ast (G \ast D) \] 
          We can also see that we are getting similar results from these 2 different approaches in part 1.3 through the 2 groups of similar images of ∂I/∂x and ∂I/∂y. Thus DoG collapses two convolutions into one without changing the result (given identical padding and true convolution on both paths).
          </div>
          </section>
          </section>

    <!-- Part 2 placeholder -->
    <section id="part2">
      <h2>Part 2 — Fun with Frequencies</h2>

          <!-- Part 2.1: Unsharp Mask (Image Sharpening) -->
    <section id="part2-1">
      <h3>Part 2.1 — Unsharp Mask (Image Sharpening)</h3>
      <p> Unsharp masking sharpens an image by boosting its high frequencies. We first produce a blurred (low-pass) version using a Gaussian \( G_\sigma \), take the high-frequency residual, then add it back with a gain \( \alpha \).</p>
    
      <div class="answer">
        <p><strong>Mathematics (and intuition)</strong></p>
        <ul>
          <li>Blur: \(\text{blur} = G_\sigma \ast I\) (keeps low-frequencies, suppresses highs)</li>
          <li>High-frequency residual: \(H = I - \text{blur}\)</li>
          <li>Sharpened image: \(I_{\text{sharp}} = I + \alpha H = (1+\alpha)\,I - \alpha\,(G_\sigma \ast I)\)</li>
          <li>Equivalent single convolution:
            <p>\[ I_{\text{sharp}} = K \ast I, \qquad K = (1+\alpha)\,\delta - \alpha\,G_\sigma \]</p>
            <p class="note" style="margin-top:8px;">Here \(\delta\) is the unit impulse (adds \(1+\alpha\) weight to the center pixel).</p>
          </li>
        </ul>
      </div>
    
      <h4>Sharpening examples — <code>taj.png</code></h4>
      <p>Five images in one row: original and four \( \alpha \) settings.</p>
      <style>
        .grid-5 { display:grid; grid-template-columns:repeat(5, minmax(0,1fr)); gap:12px; }
        @media (max-width: 1100px){ .grid-5 { grid-template-columns:repeat(3, minmax(0,1fr)); } }
        @media (max-width: 720px){ .grid-5 { grid-template-columns:repeat(2, minmax(0,1fr)); } }
      </style>
      <div class="grid-5">
        <figure>
          <img src="Media/taj.jpg" alt="taj original" loading="lazy">
          <figcaption>Original</figcaption>
        </figure>
        <figure>
          <img src="Media/taj_unsharp_1.png" alt="taj alpha=1" loading="lazy">
          <figcaption>\(\alpha=1\)</figcaption>
        </figure>
        <figure>
          <img src="Media/taj_unsharp_2.png" alt="taj alpha=2" loading="lazy">
          <figcaption>\(\alpha=2\)</figcaption>
        </figure>
        <figure>
          <img src="Media/taj_unsharp_5.png" alt="taj alpha=5" loading="lazy">
          <figcaption>\(\alpha=5\)</figcaption>
        </figure>
        <figure>
          <img src="Media/taj_unsharp_10.png" alt="taj alpha=10" loading="lazy">
          <figcaption>\(\alpha=10\)</figcaption>
        </figure>
      </div>
    
      <h4>Sharpening examples — <code>view.png</code></h4>
      <div class="grid-5">
        <figure>
          <img src="Media/view.png" alt="view original" loading="lazy">
          <figcaption>Original</figcaption>
        </figure>
        <figure>
          <img src="Media/view_unsharp_1.png" alt="view alpha=1" loading="lazy">
          <figcaption>\(\alpha=1\)</figcaption>
        </figure>
        <figure>
          <img src="Media/view_unsharp_2.png" alt="view alpha=2" loading="lazy">
          <figcaption>\(\alpha=2\)</figcaption>
        </figure>
        <figure>
          <img src="Media/view_unsharp_5.png" alt="view alpha=5" loading="lazy">
          <figcaption>\(\alpha=5\)</figcaption>
        </figure>
        <figure>
          <img src="Media/view_unsharp_10.png" alt="view alpha=10" loading="lazy">
          <figcaption>\(\alpha=10\)</figcaption>
        </figure>
      </div>

      <h4>Evaluation</h4>
        <p>Each case shows: original → blurred → sharpened (unsharp). Two examples shown.</p>
        
        <h5>Case 1: Christopher Nolan</h5>
        <figure>
          <img src="Media/Christopher_Nolan.png" alt="eval1 original" loading="lazy">
          <figcaption>Original (Case 1)</figcaption>
        </figure>
        <figure>
          <img src="Media/blur_nolan.png" alt="eval1 blurred" loading="lazy">
          <figcaption>Blurred</figcaption>
        </figure>
        <figure>
          <img src="Media/resharp_nolan.png" alt="eval1 sharpened" loading="lazy">
          <figcaption>Sharpened</figcaption>
        </figure>
        
        <h5>Case 2: James Cameron</h5>
        <figure>
          <img src="Media/James_Cameron.png" alt="eval2 original" loading="lazy">
          <figcaption>Original (Case 2)</figcaption>
        </figure>
        <figure>
          <img src="Media/blur_cameron.png" alt="eval2 blurred" loading="lazy">
          <figcaption>Blurred</figcaption>
        </figure>
        <figure>
          <img src="Media/resharp_cameron.png" alt="eval2 sharpened" loading="lazy">
          <figcaption>Sharpened</figcaption>
        </figure>

    
      <div class="answer">
        <strong>Compare &amp; observations.</strong>
            <p>It may hard to see from the examples above, but if we take closer look, we can still observe that the original image and the 
               resharpened image are actually not the same! And actually that makes sense right!</p>
        <ul>
          <li><em>Sharper but not the original:</em> Unsharp masking makes edges crisper and contrast stronger than the blurred input, but fine textures that were removed by blur cannot be fully restored (high frequencies already lost).</li>
          <li><em>Possible halos:</em> Strong edges may show bright/dark rims.</li>
          <li><em>Noise amplification:</em> Any residual noise in the blurred image will be amplified by unsharp.</li>
        </ul>
      </div>
    </section>

    <!-- Part 2.2 — Hybrid Images -->
      <section id="part2-2">
        <h3>Part 2.2 — Hybrid Images</h3>
      
        <!-- Subpart 1: code verification & cutoff-frequency tuning -->
        <section id="part2-2a">
          <h4>Code verification &amp; cutoff-frequency tuning</h4>
          <p>
            In my implementation, the effective cutoff-frequencies are controlled by the Gaussian
            standard deviations \( \sigma_\ell \) (for the low-pass) and \( \sigma_h \) (for the high-pass).
            We first verify the pipeline and tune these hyperparameters using the example
            images <code>Derek.png</code> and <code>Nutmeg.png</code>.
          </p>
      
          <div class="grid-2">
            <figure>
              <img src="Media/hybrid_8.0_4.0_result.png" alt="hybrid result σ_l=8, σ_h=4" loading="lazy">
              <figcaption>Hybrid result: \( \sigma_\ell = 8,\ \sigma_h = 4 \)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_16.0_4.0_result.png" alt="hybrid result σ_l=16, σ_h=4" loading="lazy">
              <figcaption>Hybrid result: \( \sigma_\ell = 16,\ \sigma_h = 4 \)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_8.0_8.0_result.png" alt="hybrid result σ_l=8, σ_h=8" loading="lazy">
              <figcaption>Hybrid result: \( \sigma_\ell = 8,\ \sigma_h = 8 \)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_16.0_8.0_result.png" alt="hybrid result σ_l=16, σ_h=8" loading="lazy">
              <figcaption>Hybrid result: \( \sigma_\ell = 16,\ \sigma_h = 8 \)</figcaption>
            </figure>
          </div>
      
          <div class="note">
            <strong>Observations.</strong>
            Increasing \( \sigma_\ell \) lowers the low-pass cutoff (more blur), so the hybrid’s
            far-view appearance is dominated by coarse structure; decreasing \( \sigma_\ell \) keeps more
            mid-frequency detail and can compete with the high-pass content. Increasing \( \sigma_h \)
            removes more of the base shading from the high-pass image and emphasizes fine edges; too small
            \( \sigma_h \) keeps low-frequency illumination, making the near-view look muddy. Proper
            alignment of the two sources remains critical for a convincing hybrid.
          </div>
        </section>
      </section>

      <!-- Subpart 2: Frequency analysis -->
        <section id="part2-2b">
          <h4>Frequency analysis of the hybrid pipeline</h4>
        
          <!-- local helpers for 3/5-column rows (keeps your page style) -->
          <style>
            .grid-3 { display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:12px; }
            .grid-5 { display:grid; grid-template-columns:repeat(5,minmax(0,1fr)); gap:12px; }
            @media (max-width: 1100px){ .grid-5 { grid-template-columns:repeat(3,minmax(0,1fr)); } }
            @media (max-width: 720px){ .grid-3, .grid-5 { grid-template-columns:1fr; } }
          </style>
        
          <div class="answer">
            <p><strong>Process (frequency view).</strong></p>
            <p>
              We build a hybrid image by mixing the low frequencies of image \(A\) with the high
              frequencies of image \(B\).
              A Gaussian low-pass keeps energy near DC and suppresses high spatial frequencies:
              \(L = G_{\sigma_\ell} \ast A\).
              A high-pass is formed as a residual that removes the low-pass of \(B\):
              \(H = B - G_{\sigma_h}\ast B\).
              Finally we blend:
              \[
                I_{\text{hyb}} = L + \lambda\,H
                \quad\Longleftrightarrow\quad
                \mathcal{F}\{I_{\text{hyb}}\}
                = \underbrace{\mathcal{F}\{G_{\sigma_\ell}\}}_{\text{LP mask}}\!\cdot \mathcal{F}\{A\}
                  \;+\; \lambda\Big(\mathcal{F}\{B\} - \underbrace{\mathcal{F}\{G_{\sigma_h}\}}_{\text{LP mask}}\!\cdot \mathcal{F}\{B\}\Big).
              \]
              Thus the spectrum of the hybrid contains (i) a bright concentration around the origin
              from the low-pass of \(A\), and (ii) high-frequency rings/edges from the residual of \(B\).
              The hyperparameters \( \sigma_\ell \) and \( \sigma_h \) set the effective cutoffs
              (larger \( \sigma \Rightarrow \) lower cutoff), while \( \lambda \) balances the contrast.
            </p>
          </div>
        
          <!-- three images in one row: Nolan (left), Hybrid (middle), Cameron (right) -->
          <h5>Inputs and hybrid (spatial domain)</h5>
          <div class="grid-3">
            <figure>
              <img src="Media/Hybrid_B1.jpg" alt="Christopher Nolan input image" loading="lazy">
              <figcaption>Christopher Nolan — Input Image (A)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_B_10.0_5.0_result.png" alt="Hybrid image (Nolan ⊕ Cameron)" loading="lazy">
              <figcaption>Hybrid Image (A low-pass ⊕ B high-pass)</figcaption>
            </figure>
            <figure>
              <img src="Media/Hybrid_B2.jpg" alt="James Cameron input image" loading="lazy">
              <figcaption>James Cameron — Input Image (B)</figcaption>
            </figure>
          </div>
        
          <!-- five FFT log-magnitude images in one row -->
          <h5>Log magnitude of Fourier transforms</h5>
          <div class="grid-5">
            <figure>
              <img src="Media/hybrid_B_10.0_5.0_fft_srcA.png" alt="Log |FFT| of Nolan input" loading="lazy">
              <figcaption>Log |FFT| — Nolan (input A)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_B_10.0_5.0_fft_srcB.png" alt="Log |FFT| of Cameron input" loading="lazy">
              <figcaption>Log |FFT| — Cameron (input B)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_B_10.0_5.0_fft_lowpass.png" alt="Log |FFT| of Low-Pass component" loading="lazy">
              <figcaption>Log |FFT| — Low-Pass Component \(L\)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_B_10.0_5.0_fft_highpass.png" alt="Log |FFT| of High-Pass component" loading="lazy">
              <figcaption>Log |FFT| — High-Pass Component \(H\)</figcaption>
            </figure>
            <figure>
              <img src="Media/hybrid_B_10.0_5.0_fft_hybrid.png" alt="Log |FFT| of Hybrid image" loading="lazy">
              <figcaption>Log |FFT| — Hybrid Image \(I_{\text{hyb}}\)</figcaption>
            </figure>
          </div>
          <div class="note">
            <strong>Observation &amp; illustration.</strong>
            The low-pass output concentrates energy near the DC point (center of the spectrum), which reflects its role of preserving broad, slowly varying structure while damping rapid changes. In contrast, the high-pass residual spreads energy away from the center into outer regions, consistent with emphasizing edges and fine detail by removing smooth trends.  
            <br><br>
            When we examine the hybrid’s Fourier magnitude, we see both behaviors superimposed: the central lobe inherited from the low-pass component, plus elevated outer bands contributed by the high-pass component. This matches the construction \(I_{\text{hyb}} = L + \lambda H\): <em>L</em> conveys the “overall shape,” <em>H</em> carries the “detail,” and their sum naturally yields a spectrum combining coarse content with sharp features.
          </div>
        </section>

    <!-- Subpart 3: Hybrid Images Gallery -->
      <section id="part2-2c">
        <h4>Hybrid Images Gallery</h4>
        <p>Each row shows: input A (left), the hybrid image (center), and input B (right). The caption under the hybrid indicates the \(\sigma_\ell\) (low-pass) and \(\sigma_h\) (high-pass) used.</p>
      
        <style>
          .grid-3 { display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:12px; }
          @media (max-width: 900px){ .grid-3 { grid-template-columns:1fr; } }
        </style>
      
        <!-- Row 1: Nolan ⊕ Cameron -->
        <div class="grid-3">
          <figure>
            <img src="Media/Hybrid_B1.jpg" alt="Christopher Nolan original image" loading="lazy">
            <figcaption>Christopher Nolan — Input (A)</figcaption>
          </figure>
          <figure>
            <img src="Media/hybrid_B_10.0_5.0_result.png" alt="Hybrid (Nolan ⊕ Cameron)" loading="lazy">
            <figcaption>Hybrid (A low-pass ⊕ B high-pass), \(\sigma_\ell = 10.0,\ \sigma_h = 5.0\)</figcaption>
          </figure>
          <figure>
            <img src="Media/Hybrid_B2.jpg" alt="James Cameron original image" loading="lazy">
            <figcaption>James Cameron — Input (B)</figcaption>
          </figure>
        </div>
      
        <!-- Row 2: Joaquin Phoenix ⊕ Napoleon Bonaparte -->
        <div class="grid-3">
          <figure>
            <img src="Media/E2_new.jpg" alt="Joaquin Phoenix original image" loading="lazy">
            <figcaption>Napoleon Bonaparte — Input (A)</figcaption>
          </figure>
          <figure>
            <img src="Media/hybrid_E_8.0_5.0_result_new.png" alt="Hybrid (Phoenix ⊕ Napoleon)" loading="lazy">
            <figcaption>Hybrid (A low-pass ⊕ B high-pass), \(\sigma_\ell = 8.0,\ \sigma_h = 5.0\)</figcaption>
          </figure>
          <figure>
            <img src="Media/E1_new.jpg" alt="Napoleon Bonaparte original image" loading="lazy">
            <figcaption>Joaquin Phoenix — Input (B)</figcaption>
          </figure>
        </div>
      
        <!-- Row 3: Cillian Murphy ⊕ J. Robert Oppenheimer -->
        <div class="grid-3">
          <figure>
            <img src="Media/Hybrid_C1.jpg" alt="Cillian Murphy original image" loading="lazy">
            <figcaption>Cillian Murphy — Input (A)</figcaption>
          </figure>
          <figure>
            <img src="Media/hybrid_C_4.0_2.5_result.png" alt="Hybrid (Murphy ⊕ Oppenheimer)" loading="lazy">
            <figcaption>Hybrid (A low-pass ⊕ B high-pass), \(\sigma_\ell = 4.0,\ \sigma_h = 2.5\)</figcaption>
          </figure>
          <figure>
            <img src="Media/Hybrid_C2.jpg" alt="J. Robert Oppenheimer original image" loading="lazy">
            <figcaption>J. Robert Oppenheimer — Input (B)</figcaption>
          </figure>
        </div>
        <p class="note">
          This last set of images is truly my favorite, and thanks so much for the great Oppenheimer/Cillian Murphy images from UC Berkeley Physics —
          <a href="https://physics.berkeley.edu/news/oppenheimer-july-28-panel-discussion-focuses-man-behind-movie" target="_blank" rel="noopener">Oppenheimer: Panel Discussion Focuses on the Man Behind the Movie</a>.
        </p>
      </section>


    </section>

    <!-- Lessons Learned -->
    <section id="lessons">
      <h2>Lessons Learned</h2>
      <div class="answer">
        <ul class="tight">
          <li><strong>Convolution from scratch:</strong> 4-loop（教学用）≈ 2-loop（窗口向量化）≈ SciPy <code>convolve2d</code>（前提是 padding 相同）；性能：SciPy ≫ 2-loop ≫ 4-loop。</li>
          <li><strong>Finite differences:</strong> <code>D_x</code>/<code>D_y</code> 产生有符号导数；应零居中可视化。梯度幅值 \(|\nabla I|=\sqrt{G_x^2+G_y^2}\) 旋转不变，适合做边缘强度；二值化阈值可用 0.1–0.4 × max 做质性选择。</li>
          <li><strong>Smoothing → derivative:</strong> 高斯预滤能抑噪，使边缘更干净连续，但会弱化细碎纹理。</li>
          <li><strong>DoG 等价：</strong> 由卷积结合律可知 \((I \ast G) \ast D \equiv I \ast (G \ast D)\)；在相同边界与“卷积”定义下，一次 DoG 与两次卷积数值等价。</li>
          <li><strong>Unsharp mask:</strong> \(I_{\text{sharp}}=(1+\alpha)I-\alpha(G_\sigma\ast I)=K\ast I\)。能增强清晰度，但无法完全恢复已被模糊滤掉的高频；\(\alpha\) 过大或 \(\sigma\) 过小可能产生 halo 并放大噪声。</li>
          <li><strong>实践提示：</strong> 全流程保持相同边界条件；分析时保存浮点原值，展示时再做归一化 PNG。</li>
        </ul>
      </div>
    </section>



  </main>

  <footer>
    © <script>document.write(new Date().getFullYear());</script> Project 2. All media courtesy of the author.
  </footer>
</body>
</html>
