<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Project 1 — Prokudin–Gorskii Alignment</title>
  <style>
    :root { --maxw: 980px; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0; line-height: 1.6; color: #222; background: #fafafa;
    }
    header, main, footer { max-width: var(--maxw); margin: 0 auto; padding: 20px; }
    header h1 { margin: 0 0 6px; }
    header a { color: #0b5fff; text-decoration: none; }
    .back { display: inline-block; margin-top: 6px; }
    section {
      background: #fff; border: 1px solid #eee; border-radius: 14px;
      padding: 18px; margin: 18px 0 24px; box-shadow: 0 1px 3px rgba(0,0,0,.05);
    }
    h2 { margin: 0 0 12px; font-size: 1.25rem; }
    p { margin: 8px 0; }
    .grid-2 { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
    @media (max-width: 720px) { .grid-2 { grid-template-columns: 1fr; } }

    figure { margin: 0; border: 1px solid #eee; border-radius: 12px; overflow: hidden; background: #fff; }
    figure img, figure video { display: block; width: 100%; height: auto; }
    figcaption { font-size: .9rem; padding: 10px 12px; background: #f6f7fb; border-top: 1px solid #eee; }

    .answer { background: #f4fbf6; border: 1px solid #d8f1df; border-radius: 10px; padding: 10px 12px; margin-top: 10px; }
    .note { font-size: .92rem; color: #555; background: #fff7e6; border: 1px solid #ffe2a8; border-radius: 10px; padding: 10px 12px; margin-top: 10px; }

    /* Tables */
    table { width: 100%; border-collapse: collapse; }
    thead th { text-align: left; font-weight: 600; padding: 10px 10px; background: #f6f7fb; border-bottom: 1px solid #eee; }
    tbody td { padding: 10px; border-top: 1px solid #eee; vertical-align: middle; }
    td img { width: 240px; height: auto; display: block; border-radius: 10px; border: 1px solid #eee; }
    td.number, td.time { white-space: nowrap; font-variant-numeric: tabular-nums; }
    @media (max-width: 720px) { td img { width: 100%; } }

    footer { font-size: .9rem; color: #666; }
  </style>

  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

</head>
<body>
  <header>
    <h1>Project 1: Prokudin–Gorskii Colorizing & Alignment</h1>
    <a class="back" href="../index.html">← Back to main portfolio</a>
  </header>

  <main>
    <!-- Intro -->
    <section id="intro">
      <h2>Overview</h2>
      <p>
        Sergey Prokudin–Gorskii photographed scenes using three sequential exposures through blue, green, and red filters.
        The Library of Congress scans are tall grayscale plates that stack these exposures vertically (top→bottom = B/G/R).
        This project reconstructs color images by splitting the plate into three channels, aligning <strong>G→B</strong> and
        <strong>R→B</strong> using a pure translation model, and stacking into RGB.
      </p>
      <div class="answer">
        <strong>Pipeline highlights</strong><br>
        Float processing (0–1), valid-overlap scoring (no wrap-around), small interior crop to suppress borders, SSD/NCC metrics,
        and a coarse-to-fine pyramid to handle large displacements efficiently.
      </div>
    </section>

    <!-- Single-scale -->
    <section id="single">
      <h2>Single-scale Alignment</h2>
      <p>
        For smaller plates, I use a brute-force search over integer displacements within a fixed window (e.g., ±15 px).
        The score is computed only on the overlapping interior to avoid border bias. NCC generally outperforms SSD on cross-channel matches.
      </p>
      <ol>
        <li><strong>Split:</strong> crop to a multiple of 3 rows, then slice B/G/R thirds.</li>
        <li><strong>Search:</strong> for each (dy, dx) in the window, compute valid overlap (no wrap), then crop ~5% from each side.</li>
        <li><strong>Score:</strong> SSD or NCC on the interior; pick the best (min SSD / max NCC).</li>
        <li><strong>Apply:</strong> shift G and R by the winning displacements, then stack <code>[R, G, B]</code>.</li>
      </ol>

      <div class="answer">
        <strong>Metric formulas</strong>
        <div class="grid-2">
          <div>
            <h3 style="margin:6px 0;">\(L_2\) Norm</h3>
            \[
              \left\lVert I_1 - I_2 \right\rVert_2
              = \sqrt{ \sum_{x}\sum_{y} \big( I_1(x,y) - I_2(x,y) \big)^2 }
            \]
            <div class="note" style="margin-top:6px;">
              Often we minimize the squared version (SSD) without the square root as minimizing the value itself is the same as minimizing the sqrt of the value:
              \[
                \mathrm{SSD}(I_1, I_2) = \sum_{x}\sum_{y} \big( I_1(x,y) - I_2(x,y) \big)^2 .
              \]
            </div>
          </div>
          <div>
            <h3 style="margin:6px 0;">NCC Norm</h3>
            \[
              \mathrm{NCC}(I_1, I_2) =
              \frac{ \langle \tilde I_1, \tilde I_2 \rangle }
                   { \left\lVert \tilde I_1 \right\rVert_2 \, \left\lVert \tilde I_2 \right\rVert_2 },
              \quad \tilde I = I - \overline{I}
            \]
            <div class="note" style="margin-top:6px;">
              Vector form: \( \dfrac{I_1}{\lVert I_1\rVert_2} \cdot \dfrac{I_2}{\lVert I_2\rVert_2} \).
            </div>
          </div>
        </div>
      </div>

      <!-- 3 × 4 table -->
      <table>
        <thead>
          <tr>
            <th>Image</th>
            <th>Green Channel Displacement</th>
            <th>Red Channel Displacement</th>
            <th>Processing Time (s)</th>
          </tr>
        </thead>
        <tbody>
          <!-- Replace with your single-scale results -->
          <tr>
            <td><img src="Media/out_monastery.jpg" alt="out_monastery.jpg" loading="lazy"></td>
            <td class="number">(−3, 2)</td>
            <td class="number">(3, 2)</td>
            <td class="time">1.62</td>
          </tr>
          <tr>
            <td><img src="Media/out_cathedral.jpg" alt="out_cathedral.jpg" loading="lazy"></td>
            <td class="number">(5, 2)</td>
            <td class="number">(12, 3)</td>
            <td class="time">1.86</td>
          </tr>
          <tr>
            <td><img src="Media/out_tobolsk.jpg" alt="out_tobolsk.jpg" loading="lazy"></td>
            <td class="number">(3, 3)</td>
            <td class="number">(6, 3)</td>
            <td class="time">1.78</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        Displacements are reported as <code>(dy, dx)</code> with the moving channel aligned to Blue (G→B and R→B).
      </div>
    </section>

    <!-- Pyramid -->
    <section id="pyramid">
      <h2>Pyramid-Speedup Alignment</h2>
      <p>
        For high-resolution plates, exhaustive search is too slow. I build a pyramid by 2×2 averaging (anti-alias) and downsample by 2
        until the shortest side ≤ 100 px. Alignment proceeds coarse→fine: search a window (±10) at the coarsest level, scale the displacement
        by 2 when moving up a level, and refine within ±10 around the upsampled center. Scores are NCC on cropped interiors (~5%).
      </p>
      <ol>
        <li><strong>Downsample:</strong> 2×2 mean (low-pass) then decimate by 2 — repeat until small.</li>
        <li><strong>Coarse search:</strong> find a good shift at the smallest scale.</li>
        <li><strong>Propagate & refine:</strong> double the shift per level and locally refine (±10).</li>
        <li><strong>Finalize:</strong> apply the full-resolution shift to the un-cropped channel and compose RGB.</li>
      </ol>
      <p>
        Notice that the second row of the results table, emir.tif, shows a clear misalignment, especially for red plate alignment.
        According to Anonymous Elephant's responding to this question: "The problem is that at smaller resolutions, you're still searching 
        over too small an area. My idea was to search over large areas under small resolutions and scale those down with each larger image. ..."
        I partly revised my algorithm based on that just for this emir image alone. You can see my result in the next section. It takes
        a bit of more time to run the algorithm, but the final result looks pretty nice.
      </p>

      <!-- 11 × 4 table -->
      <table>
        <thead>
          <tr>
            <th>Image</th>
            <th>Green Channel Displacement</th>
            <th>Red Channel Displacement</th>
            <th>Processing Time (s)</th>
          </tr>
        </thead>
        <tbody>
          <!-- Replace TBD rows with your pyramid results (11 rows total) -->
          <tr><td><img src="Media/out_church_pyr_simple.jpg" alt="Church — pyramid" loading="lazy"></td><td class="number">(25, 4)</td><td class="number">(58, -4)</td><td class="time">13.98</td></tr>
          <tr><td><img src="Media/out_emir_pyr_simple.jpg" alt="Emir — pyramid" loading="lazy"></td><td class="number">(49, 24)</td><td class="number">(292, -578)</td><td class="time">12.19</td></tr>
          <tr><td><img src="Media/out_harvesters_pyr_simple.jpg" alt="Monastery — pyramid" loading="lazy"></td><td class="number">(60, 17)</td><td class="number">(124, 14)</td><td class="time">13.68</td></tr>
          <tr><td><img src="Media/out_icon_pyr_simple.jpg" alt="Icon — pyramid" loading="lazy"></td><td class="number">(41, 17)</td><td class="number">(89, 23)</td><td class="time">14.65</td></tr>
          <tr><td><img src="Media/out_italil_pyr_simple.jpg" alt="Italil — pyramid" loading="lazy"></td><td class="number">(38, 21)</td><td class="number">(77, 35)</td><td class="time">15.02</td></tr>
          <tr><td><img src="Media/out_lastochikino_pyr_simple.jpg" alt="Lastochikino — pyramid" loading="lazy"></td><td class="number">(-3, -2)</td><td class="number">(75, -9)</td><td class="time">14.38</td></tr>
          <tr><td><img src="Media/out_lugano_pyr_simple.jpg" alt="Lugano — pyramid" loading="lazy"></td><td class="number">(41, -16)</td><td class="number">(93, -29)</td><td class="time">14.89</td></tr>
          <tr><td><img src="Media/out_melons_pyr_simple.jpg" alt="Melons — pyramid" loading="lazy"></td><td class="number">(82, 11)</td><td class="number">(179, 13)</td><td class="time">14.44</td></tr>
          <tr><td><img src="Media/out_self_portrait_pyr_simple.jpg" alt="Self_Portrait — pyramid" loading="lazy"></td><td class="number">(79, 29)</td><td class="number">(176, 37)</td><td class="time">14.12</td></tr>
          <tr><td><img src="Media/out_siren_pyr_simple.jpg" alt="Siren — pyramid" loading="lazy"></td><td class="number">(49, -6)</td><td class="number">(96, -25)</td><td class="time">14.96</td></tr>
          <tr><td><img src="Media/out_three_generations_pyr_simple.jpg" alt="Three_Generations — pyramid" loading="lazy"></td><td class="number">(53, 14)</td><td class="number">(112, 11)</td><td class="time">14.18</td></tr>
        </tbody>
      </table>

      <div class="note">
        Using fixed parameters across images keeps the results comparable. If an image has strong black borders, a slightly larger interior crop can help.
      </div>
    </section>

    <!-- Revised Emir.tif -->
    <section id="emir-revised">
      <h2>Revised <code>emir.tif</code> — Robust Red-Plate Alignment</h2>
      <p>
        The red plate of <em>emir.tif</em> was difficult to align using plain pyramid&nbsp;+&nbsp;NCC. At small scales, the best shift often sat at
        the window’s edge and then exploded when multiplied by 2 across levels, and NCC on intensities was unstable on low-texture patches.
        I implemented a targeted revision that fixes both issues while remaining simple and fast.
      </p>
      <ol>
        <li>
          <strong>Safer NCC with low-texture guard (<code>ncc_score_emir</code>)</strong> —
          zero-mean normalize both patches and <em>skip</em> comparisons whose std dev is below a threshold
          (returns −1.0). This prevents flat sky/wall regions from “winning” randomly.
        </li>
        <li>
          <strong>Coarse→fine two-pass per level (<code>align_pyramid_simple_emir</code>)</strong> —
          at the coarsest level use a <em>large</em> window (25% of min side, capped at 80). At each level:
          (a) do a gradient-NCC search around the upscaled center; then
          (b) refine with intensity-NCC in a smaller window. Double (dy, dx) between levels.
        </li>
        <li>
          <strong>Interior crop on the overlap</strong> —
          score on the overlap’s interior (≈5%) to suppress black/white scanner borders.
        </li>
      </ol>

      <!-- Result image + metrics -->
      <div class="grid-2">
        <figure>
          <!-- Update the src path to wherever you publish the revised emir output -->
          <img src="Media/out_emir_revision_pyr_simple.jpg" alt="Revised emir.tif result" loading="lazy">
          <figcaption>Revised emir.tif — gradient-first NCC + one-time edge expansion.</figcaption>
        </figure>

        <div>
          <table>
            <thead>
              <tr>
                <th>Metric</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody>
              <!-- Replace TBD with your real numbers from the run -->
              <tr><td>Green Channel Displacement (G→B)</td><td class="number">(49, 24)</td></tr>
              <tr><td>Red Channel Displacement (R→B)</td><td class="number">(103, 45)</td></tr>
              <tr><td>Processing Time (s)</td><td class="time">93.59</td></tr>
            </tbody>
          </table>

          <div class="answer">
            <strong>Why it works</strong><br>
            Edges dominate at coarse scales and are invariant to exposure differences; the low-texture guard avoids random NCC maxima;
            and the one-time window expansion prevents wrong coarse guesses from being amplified by the 2× step between levels.
          </div>
        </div>
      </div>
    </section>

    <!-- Bonus -->
    <section id="bonus">
      <h2>Bonus Images</h2>
      <p>Additional plates aligned with the same pipeline and fixed settings.</p>

      <!-- 4 × 4 table -->
      <table>
        <thead>
          <tr>
            <th>Image</th>
            <th>Green Channel Displacement</th>
            <th>Red Channel Displacement</th>
            <th>Processing Time (s)</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><img src="Media/out_railroad_pyr_simple.jpg" alt="Railroad — pyramid" loading="lazy"></td><td class="number">(48, -9)</td><td class="number">(147, -20)</td><td class="time">14.38</td></tr>
          <tr><td><img src="Media/out_carving_pyr_simple.jpg" alt="Carving — pyramid" loading="lazy"></td><td class="number">(52, 0)</td><td class="number">(124, -13)</td><td class="time">14.20</td></tr>
          <tr><td><img src="Media/out_Gift_pyr_simple.jpg" alt="Gift — pyramid" loading="lazy"></td><td class="number">(68, -7)</td><td class="number">(142, -19)</td><td class="time">14.64</td></tr>
          <tr><td><img src="Media/out_Smolensk_pyr_simple.jpg" alt="Smolensk — pyramid" loading="lazy"></td><td class="number">(52, 18)</td><td class="number">(112, 23)</td><td class="time">14.22</td></tr>
        </tbody>
      </table>
    </section>
  </main>

  <footer>
    © <script>document.write(new Date().getFullYear());</script> Project 1. All images produced by the author.
  </footer>
</body>
</html>
